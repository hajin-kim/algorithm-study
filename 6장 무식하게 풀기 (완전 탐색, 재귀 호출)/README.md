# 6장 무식하게 풀기

## 6.1 브루트 포스, 완전 탐색

- 무식하게 풀기 (brute-force): 컴퓨터의 연산 능력을 활용해 가능한 경우의 수를 모두 탐색합니다.
- 완전 탐색 (exhaustive search): 가능한 방법을 모두 만들어봅니다.
- 구글링해보면 컨텍스트가 다르다던지, 어느 하나가 상위 개념이라는 언급도 있지만 어쨌든 두 단어가 의미하는 바는 비슷합니다.

완전 탐색과 시간 복잡도

- 보통 컴퓨터는 초당 1억번 정도 연산한다고 가정합니다.
- Permutation 완전 탐색의 시간 복잡도는 `O(n!)`입니다.
- 10명을 줄 세우기의 경우의 수는 10!, 약 360만 가지로, 사람은 불가능하지만 컴퓨터는 1초도 안 걸려서 해결할 수 있습니다.
- 따라서 완전 탐색은 입력의 크기가 작은 경우 고려할 수 있는 방법입니다. 대신 입력의 크기가 커지면 시간 제한을 초과할 수도 있습니다.
- 가지치기 등의 더 빠른 알고리즘의 기반이 되기도 하므로 잘 익혀두면 좋습니다.

## 6.2 재귀 호출

- 함수가 자기 자신을 호출합니다.

Sigma(n) 예시

```c++
// 1부터 n (n >= 1)까지의 합을 계산하는 함수

int sum(int n) {
    int ret = 0;
    for (int i = 1; i <= n; ++i) {
        ret += i;
    }
    return ret;
}

int recursiveSum(int n) {
    if (n == 1) return 1; // base case
    return n + recursiveSum(n - 1);
}
```

- 문제를 n개의 조각으로 쪼갠다고 생각합시다.
- n에 대한 처리를 직접 하고, 1부터 (n - 1)에 대한 처리를 재귀로 위임합니다.
- 이 문제는 재귀로 얻는 이점이 없지만, 이에 관해서는 후술하겠습니다.

기저 사례

- 기저 사례 (base case): 더 이상 문제를 쪼갤 수 없는 부분입니다.
- 가능한 모든 입력이 기저 사례로 계산될 수 있으면 좋습니다. 예컨대 위에서 `if (n == 2) return 3;`을 기저 사례로 골랐다면 입력이 n = 1일 때 문제가 발생합니다.

### 예제: 중첩 반목문 대체하기

```c++
// n개의 원소 0, 1, ... , n - 1 중 4개를 고르는 모든 조합을 찾는 알고리즘
void combination4(int n) {
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            for (int k = j + 1; k < n; ++k) {
                for (int l = k + 1; l < n; ++l) {
                    printf("%d %d %d %d\n", i, j, k, l);
                }
            }
        }
    }
}
```

- 이 코드는 4개의 조각으로 나눌 수 있습니다.
- 각 조각에서 1개의 원소를 고르고, 나머지 원소를 재귀 호출로 고르는 재귀 함수를 작성할 수 있습니다.
- 이때 각 조각의 입력을 다음으로 정의할 수 있습니다.
  - `n`: 전체 원소의 수
  - `picked`: 지금까지 고른 원소들
  - `toPick`: 더 고를 원소의 수

```c++
// n개의 원소 0, 1, ... , n - 1 중 `toPick`개를 고르는 모든 조합을 찾는 알고리즘
void combinationRecursive(int n, vector<int>& picked, int toPick) {
    // 기저 사례: 더 고를 원소가 없을 때 고른 원소들을 출력합니다.
    if (toPick == 0) {
        printPicked(picked);
        return;
    }
    // 고를 수 있는 가장 작은 번호를 구합니다.
    int smallest = picked.empty() ? 0 : picked.back() + 1;
    /**
     * 이 재귀에서 원소 하나를 고릅니다.
     * 예컨대 n = 7이고 picked = {0, 2}이면
     *  - smallest = 3입니다.
     *  - 가능한 next는 {4, 5, 6}입니다.
     */
    for (int next = smallest; next < n; ++next) {
        picked.push_back(next);
        combinationRecursive(n, picked, toPick - 1);
        picked.pop_back();
    }
}
```

- 이 코드는 `toPick`이 몇이든 상관없이 이용할 수 있다는 장점이 있습니다.
- 재귀를 이용하면 반복문만을 이용하면 얻을 수 없는 흐름을 얻을 수 있습니다.
- 완전 탐색을 구현할 때 유용합니다.

### 예제: 보글 게임 (문제 ID: BOGGLE, 난이도: 하)

- 5 * 5 크기의 알파벳 격자가 주어집니다.
- 상하좌우/대각선으로 인접한 칸들의 글자를 이어서 단어를 찾는 게임입니다.
- 저희의 목적은 시작 좌표, 단어가 주어질 때, 해당 단어가 보글 게임판에 존재하는지 여부를 구하는 것입니다.

`bool hasWord(int y, int x, const string& word);`

문제 풀의시 유의할 점

- 다음 글자가 될 수 있는 칸이 여러 개인 경우, 그 중 어느 글자를 골라야 할지 미리 알 수 없습니다.
- 간단한 방법은, 다음 글자가 될 수 있는 칸을 모두 시도해 보는 것입니다.

### 문제의 분할

- 각 글자를 하나의 조각으로 간주합니다.

1. 현재 위치의 글자가 word\[1\]과 다르면 `return false;`
2. 현재 word에서 첫 글자를 제외한 나머지를 word\[1..\]를 찾습니다. 이때 인접한 여덟 칸을 모두 시도해봅니다.

### 기저 사례 선택

1. 위치 (y, x)가 현재 word의 첫 글자가 아니면 항상 실패합니다.
2. 1을 통과하고 원하는 단어가 한 글자인 경우 항상 성공합니다.

이때 순서가 바뀌면 안 됩니다.

간결한 코드를 작성하는 방법 중 하나로, 입력이 잘못되거나 범위를 벗어난 경우도 기저 사례로 처리하는 것이 있습니다. 그러면 처음 함수를 호출할 때, 함수를 재귀할 때마다 매번 입력 오류를 검사하는데, 예컨대 현재 글자가 격자의 구석에 있는 경우 이러한 반복적인 검사가 유용합니다.

### 구현

```c++
const int dx[8] = { -1, -1, -1, 1, 1, 1, 0, 0 };
const int dy[8] = { -1, 0, 1, -1, 0, 1, -1, 1 };

bool hasWord(int y, int x, const string& word) {
    // 기저 사례 1: 시작 위치가 범위 밖이면 무조건 실패
    if (!inRange(y, x)) return false;
    // 기저 사례 2: 첫 글자가 일치하지 않으면 실패
    if (board[y][x] != word[0]) return false;
    // 기저 사례 3: (기저 사례 2를 통과하고) 단어 길이가 1이면 성공
    if (word.size() == 1) return true;
    
    // 인접한 여덟 칸을 검사합니다.
    for (int direction = 0; direction < 8; ++direction) {
        int nextY = y + dy[direction], nextX = x + dx[direction];
        // 다음 칸이 범위 안에 있는지, 첫 글자는 일치하는지 여부는 재귀 호출 시 기저 사례 부분에서 검사합니다.
        // 따라서 재귀 호출을 하는 이 시점에는 확인할 필요가 없습니다.
        if (hasWord(nextY, nextX, word.substr(1)))
            return true;
    }
    return false;
}
```

### 시간 복잡도 분석

- 완전 탐색 시간 복잡도 계산은 대체로 단순합니다. 가능한 후보의 최대 개수를 세어보면 됩니다.
- 위 문제에서 최악의 경우는 답이 존재하지 않을 때지만, 저희의 알고리즘은 그걸 모릅니다. 예컨대 word = "AA...AH" 일 때 H가 격자에 아예 없는 경우입니다.
- 각 칸에는 최대 여덟 개의 이웃이 있고, 탐색은 단어의 길이 N에 대해 N - 1번 이루어집니다. 따라서 시간 복잡도는 `O(8^N)`입니다.
- 시간 소요가 지수적으로 증가한다는 의미이므로, 단어의 길이기 조금이라도 길어진다면 3부의 다른 장에서 다루는 설계 패러다임 등을 사용해야 합니다.

### 완전 탐색 레시피

1. 완전 탐색은 존재하는 모든 후보를 검사하므로 걸리는 시간이 이에 비례합니다. 최대 크기의 입력을 가정했을 때 후보의 개수를 계산하고 제한 시간 안에 해결할 수 있을지 가늠해야 합니다. 불가능하면 3부의 패러다임들을 적용합니다.
2. 답의 후보를 만드는 과정을 여러 선택으로 쪼개 조각으로 간주합니다.
3. 하나의 조각을 선택해 답의 일부를 만들고, 답의 나머지 부분을 재귀 호출을 통해 완성합니다.
4. 조각이 하나 남았거나 없는 경우 답의 후보가 만들어진 것입니다. 이를 기저 사례로 처리합니다.

### 이론적 배경: 재귀 호출과 부분 문제

- 문제: **입력이 주어졌을 때** 계산해야 하는 것을 의미합니다.
- 부분 문제: 어떤 문제를 구성하는 작은 문제입니다. 그 자체로 하나의 문제라고 볼 수 있습니다.

<!-- ## 6.3 문제: 소풍 (문제 ID: PICNIC, 난이도: 하) -->
