# 08장 동적 계획법

## 8.1 도입

- DP (dynamic programming)
- 이름의 유래: 멋있어서... dynamic이나 programming과는 별 관련이 없고 그나마 적절한 번역은 동적 계획법입니다.

### 중복되는 부분 문제

- DP는 큰 의미에서 분할 정복과 같은 접근 방식입니다. 문제를 부분 문제로 나누어 풉니다.
- 그런데 어떤 부분 문제는 중복되어 사용될 수 있습니다.
- **DP는 이러한 계산 결과를 저장 및 재활용하여 속도의 향상을 꾀하는 기법**입니다.
- 이때 2번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblem)라고 합니다.
- 이미 계산한 값을 저장할 메모리 공간을 캐시(cache)라고 합니다.

### 이항 계수 (binomial coefficient)

점화식

- 수학에서 재귀적으로(recursively) 정의되는 함수를 의미합니다.
- 이항 계수의 점화식은 다음과 같습니다.

$$ \binom{n}{r} = \binom{n-1}{r-1} + \binom{n-1}{r} $$

구현

```c++
int bino(int n, int r) {
    // 기저 사례
    // r = 0 (고를 원소가 없는 경우)
    // n = r (모든 원소를 다 고르는 경우)
    if (r == 0 || n == r)
        return 1;

    return bino(n - 1, r - 1) + bino(n - 1, r);
}
```

- 점화식을 그대로 코드로 옮기면 됩니다.
- 어떠한 반복문도 없습니다.
- 같은 값을 두 번 이상 계산할 일이 빈번합니다.

시간 복잡도

- 이 코드는 n과 r이 커질수록 수행 시간이 기하급수적으로 늘어납니다.
- n이 1 증가할 때마다 함수 호출 횟수가 2배씩 늘어납니다. -> $O(2^n)$

최적화

- 동일한 n과 r에 대해 `bino(n, r)`의 계산 결과는 같습니다.
- 따라서 이전에 계산한 값을 저장해 두었다가 재사용이 필요할 때 꺼내 쓰면 됩니다.
- 이러한 최적화 기법을 **메모이제이션(memoization)**이라고 합니다.
- 최적화를 적용하면 n = 25에서 함수 호출 횟수를 10,400,599회에서 181회로 줄일 수 있습니다.
- 시간 복잡도는 $O(n^2)$ 정도로 감소합니다.

```c++  
// -1로 초기화해 둔다.
int cache[30][30] = { -1, };
int bino2(int n, int r) {
    // 기저 사례
    if (r == 0 || n == r)
        return 1;

    // -1이 아니라면 한 번 계산했던 값이니 곧장 반환
    if (cache[n][r] != -1)
        return cache[n][r];

    // 직접 계산한 뒤 배열에 저장
    return cache[n][r] = bino2(n - 1, r - 1) + bino2(n - 1, r);
}
```

### 메모이제이션을 적용할 수 있는 경우

- **참조 투명** 함수(referential transparent function)이어야 합니다.
- 함수 내부에서 전역 변수, 표준 및 파일 입력, 클래스 멤버 변수, 랜덤, 현재 시각 등의 다른 입력이나 상태를 사용하면 안 됩니다.
- 함수에 영향을 주는 입력은 오로지 파라미터로만 주어져야 합니다.
- 그래야 파라미터가 같다면 출력이 항상 같기 때문입니다.

### 메모이제이션의 구현 패턴

- 항상 기저 사례를 제일 먼저 처리합니다. 범위를 벗어난 입력 등 캐시 접근 시 발생할 수 있는 예외 상황을 방지하기 위함입니다.
- 캐시의 크기를 넉넉히 하고 값을 미리 초기화해둡니다. 이때 함수의 반환 값이 될 수 없는 값으로 초기화합니다.
